<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>River Ranker</title>
  <link rel="manifest" href="manifest.webmanifest">
  <meta name="theme-color" content="#ffffff">
  <link rel="icon" type="image/png" href="/favicon.png">
  <style>
    body { font-family: -apple-system, system-ui, Helvetica, Arial, sans-serif; margin: 0; padding: 16px; }
    header { display:flex; align-items:center; gap:8px; flex-wrap:wrap; }
    h1 { font-size: 20px; margin: 0 8px 0 0; }
    .pill { display:inline-block; padding:2px 8px; border-radius:999px; border:1px solid #ccc; font-size:12px; color:#333; }
    .controls { margin:10px 0; display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    input[type="number"] { width: 80px; padding:6px; }
    button { padding:8px 12px; border:1px solid #333; background:#fff; border-radius:8px; font-size:14px; }
    .legend { font-size:12px; color:#555; margin:8px 0; }
    .chip { display:inline-block; padding:2px 8px; border-radius:999px; border:1px solid rgba(0,0,0,0.1); font-size:12px; }
    .flag { display:inline-block; padding:4px 10px; border-radius:10px; font-size:12px; font-weight:600; border:1px solid #333; background:#eef6ff; color:#0b5cab; }
    .flag.tailwater { background:#e6f4ff; color:#0b5cab; border-color:#0b5cab; }
    .flag.springfed { background:#eaf7ea; color:#0a6b2b; border-color:#0a6b2b; }
    table { width:100%; border-collapse: collapse; }
    th, td { border:1px solid #e5e5e5; padding:8px; vertical-align:top; font-size:14px; }
    th { background:#fff3e6; text-align:left; }
    tr:hover { background:#fafafa; }
    .small { font-size:12px; color:#666; }
    .meta { font-size:12px; color:#444; margin-top:4px; }
    .btn { display:inline-block; padding:6px 10px; margin:6px 6px 0 0; border:1px solid #333; text-decoration:none; border-radius:8px; font-size:13px; }
    details.dropdown { display:inline-block; position:relative; }
    details.dropdown > summary { list-style:none; cursor:pointer; }
    details.dropdown > summary::-webkit-details-marker { display:none; }
    details.dropdown[open] > .menu { display:block; }
    .menu { display:none; position:absolute; top:100%; left:0; background:#fff; border:1px solid #ccc; border-radius:8px; padding:6px; min-width:220px; z-index:20; box-shadow:0 4px 16px rgba(0,0,0,0.15); }
    .menu a { display:block; padding:6px 8px; font-size:13px; color:#111; text-decoration:none; border-radius:6px; }
    .menu a:hover { background:#f2f2f2; }
    /* Modal */
    .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.35); display:none; align-items:center; justify-content:center; padding:16px; z-index:1000; }
    .modal { background:#fff; color:#222; max-width:820px; width:100%; max-height:80vh; overflow:auto; border-radius:12px; padding:16px; box-shadow: 0 10px 30px rgba(0,0,0,0.25); }
    .modal h2 { margin: 0 0 8px 0; font-size:18px; }
    .modal h3 { margin: 16px 0 6px 0; font-size:15px; }
    .modal p, .modal li { font-size:14px; line-height:1.45; color:#333; }
    .modal .close { float:right; border:1px solid #333; border-radius:8px; padding:4px 8px; background:#fff; }
  </style>
</head>
<body>
  <header>
    <h1>River Ranker</h1><span class="pill">v1</span>
    <span class="pill" id="mode-pill">near me</span>
    <span class="pill" id="season-pill"></span>
    <a href="#" id="how-link" class="btn" style="margin-left:auto;">How this works</a>
  </header>

  <div class="controls">
    <label>Radius mi <input id="radius" type="number" min="10" max="500" step="10" value="250"></label>
    <label>Max rivers <input id="limit" type="number" min="5" max="50" step="5" value="25"></label>
    <button id="refresh">Refresh</button>
    <span class="small" id="origin"></span>
    <label class="small"><input type="checkbox" id="hasTempOnly"> Has temp only</label>
    <label class="small"><input type="checkbox" id="hideWarm"> Hide warm (>68¬∞F)</label>
    <button id="download-json" class="btn">Download JSON</button>
  </div>
  <div class="small" id="status"></div>

  <div class="legend">
    <span class="chip" style="background:#1db954">live</span>
    <span class="chip" style="background:#75d696">&lt;24h</span>
    <span class="chip" style="background:#ffdd57">24‚Äì72h</span>
    <span class="chip" style="background:#ffa141">72h‚Äì1w</span>
    <span class="chip" style="background:#ff5d5d">&gt;1w</span>
  </div>

  <table id="table">
    <thead>
      <tr>
        <th>#</th><th>River</th><th>Flow ‚Ä¢ Freshness ‚Ä¢ Temp</th><th>Mi</th><th>Score</th><th>Open</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <!-- How it works modal -->
  <div id="how-modal" class="modal-overlay" role="dialog" aria-modal="true" aria-labelledby="how-title">
    <div class="modal">
      <button class="close" id="how-close" aria-label="Close">Close</button>
      <h2 id="how-title">How this works</h2>
      <p>River Ranker is a scouting tool to help you quickly spot promising trout water near you. It is not a substitute for local knowledge, on-the-ground conditions, or official regulations.</p>
      <h3>Where the data comes from</h3>
      <ul>
        <li><b>Flows and temperature:</b> Live readings from the USGS Water Services ‚ÄúInstantaneous Values (IV)‚Äù API. Some gages report only flow (CFS); temperature is included when the gage has a temp sensor.</li>
        <li><b>Freshness:</b> The colored chip shows how recent the last flow reading is.</li>
        <li><b>Fly shops:</b> Nearby shop info is looked up from OpenStreetMap data and may be incomplete.</li>
      </ul>
      <h3>How rivers are ranked</h3>
      <ul>
        <li><b>Flow suitability:</b> Prefers moderate flows typical for wade fishing on trout streams; very high water scores low.</li>
        <li><b>Water temperature:</b> Favors roughly 52‚Äì62¬∞F, and tapers above/below.</li>
        <li><b>Distance:</b> Closer rivers score higher.</li>
        <li><b>Data freshness:</b> More recent gage updates score higher.</li>
        <li><b>Season:</b> A small seasonal adjustment is applied.</li>
      </ul>
      <p>Names are normalized and obviously non-trout waters (e.g., canals, reservoirs) are filtered out. This is a best‚Äëeffort heuristic and will not be perfect.</p>
      <h3>Important limitations</h3>
      <ul>
        <li>Coverage is limited to California and gaged waters; ungaged creeks won‚Äôt appear.</li>
        <li>Flows and temps can change quickly due to weather or dam operations; always verify current conditions.</li>
        <li>Species and ‚Äúbest flies‚Äù are educated guesses based on region and season; treat as a starting point.</li>
        <li>Regulations can change mid‚Äëseason. Always check the official CDFW regulations before you fish.</li>
        <li>Use caution around water. High or swift flows can be dangerous even when a river looks good on the map.</li>
      </ul>
      <h3>Sources</h3>
      <ul>
        <li>USGS Water Services (IV): <a href="https://waterservices.usgs.gov/" target="_blank" rel="noopener">waterservices.usgs.gov</a></li>
        <li>OpenStreetMap (shops): <a href="https://www.openstreetmap.org/" target="_blank" rel="noopener">openstreetmap.org</a></li>
        <li>California fishing regulations (search): <a href="https://wildlife.ca.gov/Regulations" target="_blank" rel="noopener">wildlife.ca.gov/Regulations</a></li>
      </ul>
      <p class="small">This app does not store your location. Your approximate location is used locally to find nearby gages.</p>
    </div>
  </div>

  <script>
    // cache-bust service worker on dev reloads
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.getRegistrations().then(rs => rs.forEach(r => r.update())).catch(() => {});
    }
    // Config
    const PARAM_FLOW = "00060";
    const PARAM_TEMP = "00010";
    const MONTH = new Date().getMonth()+1;
    const SUMMER = MONTH>=6 && MONTH<=9;
    const SEASON_LABEL = SUMMER ? "Summer" : (MONTH<=2 || MONTH===12 ? "Winter" : (MONTH<=5 ? "Spring" : "Fall"));
    document.getElementById('season-pill').textContent = `Season: ${SEASON_LABEL}`;

    const FRESH = [
      { maxHrs: 1,    color: "#1db954", label: "live" },
      { maxHrs: 24,   color: "#75d696", label: "<24h" },
      { maxHrs: 72,   color: "#ffdd57", label: "24‚Äì72h" },
      { maxHrs: 168,  color: "#ffa141", label: "72h‚Äì1w" },
      { maxHrs: Infinity, color: "#ff5d5d", label: ">1w (drop)" }
    ];

    const SPECIES_ICON = { rainbow:"üü¶", brown:"üü®", brook:"üü•", cutthroat:"üüß", steelhead:"üéØ" };
    const SPECIES_COLOR = { rainbow:"#4ea3ff", brown:"#b08968", brook:"#e63946", cutthroat:"#ff8c42", steelhead:"#6c757d" };
    const defaultSpecies = ["rainbow"];

    // Whitelists and name guards (CA focus, non-exhaustive)
    const TROUT_RIVER_WHITELIST = new Set([
      "Sacramento River", "American River", "Feather River", "Yuba River", "Truckee River",
      "McCloud River", "Pit River", "Owens River", "Lower Owens River", "Upper Owens River",
      "Kern River", "Kings River", "San Joaquin River", "Stanislaus River", "Tuolumne River",
      "Merced River", "Trinity River", "Klamath River", "Smith River", "Mattole River",
      "Eel River", "Russian River", "Fall River", "Hat Creek", "Putah Creek", "Upper Sacramento River",
      "North Fork Yuba River", "Middle Fork Yuba River", "South Fork Yuba River", "Lower Yuba River"
    ]);
    const TROUT_CREEK_WHITELIST = new Set([
      "Hat Creek", "Putah Creek", "Hot Creek", "Silver Creek", "Rush Creek", "Lee Vining Creek",
      "Upper Truckee River", "Mammoth Creek", "Big Pine Creek", "Bishop Creek"
    ]);
    const LARGE_TAILWATER_WHITELIST = new Set([
      "Sacramento River", "American River", "Feather River", "Trinity River", "Klamath River"
    ]);
    const SPRINGFED_WHITELIST = new Set(["Fall River", "Hat Creek"]);
    const STEELHEAD_RIVERS = new Set(["Russian River", "American River", "Trinity River", "Klamath River", "Eel River", "Smith River"]);
    const EXTRA_EXCLUDE = /\b(Byron|Middle River|Old River|False River|Forebay|Franks\s+Tract|Clifton\s+Court|Andrus\s+Island)\b/i;

    // Optimization guide additions
    const WARM_WATER_LIST = new Set([
      "Guadalupe River", "Salinas River", "Napa River", "Pajaro River", "San Benito River",
      "San Antonio River", "Nacimiento River", "Cosumnes River", "Bear River", "San Lorenzo River",
      "Lower American River", "Russian River"
    ]);
    // Approximate ideal flows (cfs) for some rivers; fallback to 30d median otherwise
    const IDEAL_FLOW = new Map([
      ["Truckee River", 400],
      ["Little Truckee River", 150],
      ["McCloud River", 400],
      ["Upper Sacramento River", 350],
      ["Pit River", 600],
      ["Feather River", 1200],
      ["American River", 1200],
      ["Yuba River", 900],
      ["Sacramento River", 6000],
      ["Putah Creek", 250],
      ["Hat Creek", 200]
    ]);
    // Hatch data (starter; extend over time)
    const HATCH_DATA = {
      "Truckee River": { 8:["PMD","Caddis","Terrestrials"], 9:["BWO","Oktober Caddis"] },
      "McCloud River": { 8:["Caddis","Little Yellow Stones"], 9:["BWO"] },
      "Hat Creek": { 8:["Caddis","PMD"], 9:["BWO"] }
    };

    // Device + map links
    const UA = navigator.userAgent || "";
    const IS_IOS = /iPad|iPhone|iPod/.test(UA) && !window.MSStream;
    const IS_ANDROID = /Android/.test(UA);
    function mapHrefFor(lat, lon){
      if (IS_IOS) return `https://maps.apple.com/?ll=${lat},${lon}`;
      return `https://www.google.com/maps/search/?api=1&query=${lat},${lon}`;
    }

    // Species heuristic (very rough) by location + season
    function guessSpecies(lat, lon){
      const coastal = lon > -124.3 && lon < -121.0; // CA coastal band
      const farNorth = lat > 40.5;
      const highSierra = lon > -121.5 && lat > 36 && lat < 40.5; // Sierra crest approximation
      const species = new Set();
      species.add("rainbow");
      if (highSierra || farNorth) species.add("brook");
      if (!highSierra) species.add("brown");
      const winter = SEASON_LABEL === "Winter";
      if (coastal && winter) species.add("steelhead");
      return Array.from(species);
    }

    function speciesChips(keys){
      return keys.map(k => `<span class="chip" style="background:${SPECIES_COLOR[k]||'#ddd'};color:#fff">${k}</span>`).join(" ");
    }

    function bestFliesForSeason(){
      switch (SEASON_LABEL){
        case "Winter": return ["midges", "BWO", "eggs (steelhead)", "stonefly nymphs"];
        case "Spring": return ["March Brown", "BWO", "caddis", "stoneflies"];
        case "Summer": return ["hoppers", "PMD", "caddis", "ants", "small streamers"];
        case "Fall": default: return ["October Caddis", "BWO", "mahogany duns", "streamers"];
      }
    }

    // Fly shop lookup removed per product decision

    function g(q){ return "https://www.google.com/search?q=" + encodeURIComponent(q); }
    function chatGPTUrl(prompt){ return `https://chatgpt.com/?q=${encodeURIComponent(prompt)}&hints=search`; }
    function buildSuggestedFliesPrompt(riverName){
      const today = new Date();
      const dateStr = today.toLocaleDateString();
      return `You are an expert fly fishing guide. Suggest fly patterns (dry, nymph, streamer, terrestrials) for trout on ${riverName} in California for ${dateStr} in the ${SEASON_LABEL} season. Include sizes and brief when/where to fish them. Keep it concise and actionable.`;
    }
    function buildLocalShopsPrompt(lat, lon){
      const today = new Date().toLocaleDateString();
      return `List nearby fly shops for fly fishing near coordinates ${lat}, ${lon} in California as of ${today}. Provide name, distance, address, and phone. Keep to the closest 5 and include links if available.`;
    }

    function buildRegsPrompt(riverName, siteName){
      return `Search the web and provide the most current and up-to-date fishing regulations specifically for trout on ${riverName} near "${siteName}" in California. Include season dates, gear restrictions (artificials, barbless), bag and possession limits, special closures or exceptions, and any catch-and-release rules. Cite and link the official CDFW page(s) you used. Keep it concise and actionable.`;
    }

    function titleCase(s){ return s.toLowerCase().replace(/\b([a-z])/g, m => m.toUpperCase()); }
    function normalizeRiverName(siteName){
      // Expand common abbreviations and clean whitespace
      let s = siteName
        .replace(/\bR\.?\b/ig, "River")
        .replace(/\bRiv\.?\b/ig, "River")
        .replace(/\bCr\.?\b/ig, "Creek")
        .replace(/\bFk\b/ig, "Fork")
        .replace(/\bN\.?\s?Fork\b/ig, "North Fork")
        .replace(/\bS\.?\s?Fork\b/ig, "South Fork")
        .replace(/\bM\.?\s?Fork\b/ig, "Middle Fork")
        .replace(/\bE\.?\s?Fork\b/ig, "East Fork")
        .replace(/\bW\.?\s?Fork\b/ig, "West Fork")
        .replace(/\s+/g, " ")
        .trim();

      // 1) "North Fork Yuba River" ‚Üí keep
      let m = s.match(/((?:North|South|Middle|East|West|Little)\sFork\s+[A-Z][A-Za-z']+(?:\s+[A-Z][A-Za-z']+)*)\s+(River|Creek)/i);
      if (m) return titleCase(`${m[1]} ${m[2]}`);

      // 2) "North Fork of Yuba River"
      m = s.match(/((?:North|South|Middle|East|West|Little)\sFork)\s+of\s+([A-Z][A-Za-z']+(?:\s+[A-Z][A-Za-z']+)*)\s+(River|Creek)/i);
      if (m) return titleCase(`${m[1]} ${m[2]} ${m[3]}`);

      // 3) "Yuba River - North Fork" or "Yuba River (North Fork)"
      m = s.match(/([A-Z][A-Za-z']+(?:\s+[A-Z][A-Za-z']+)*)\s+(River|Creek).{0,12}\b(North|South|Middle|East|West|Little)\s+Fork\b/i);
      if (m) return titleCase(`${m[3]} Fork ${m[1]} ${m[2]}`);

      // 4) Abbrev forms like "NF American River"
      m = s.match(/\b(North|South|Middle|East|West|Little)\s*F(?:ork)?\b\s+([A-Z][A-Za-z']+(?:\s+[A-Z][A-Za-z']+)*)\s+(River|Creek)/i);
      if (m) return titleCase(`${m[1]} Fork ${m[2]} ${m[3]}`);

      // 5) Generic "<Name> River|Creek"
      m = s.match(/([A-Z][A-Za-z']+(?:\s+[A-Z][A-Za-z']+)*)\s+(River|Creek)/i);
      if (m) return titleCase(`${m[1]} ${m[2]}`);

      // 6) "<Name> Fork" (no parent river captured)
      m = s.match(/([A-Z][A-Za-z']+(?:\s+[A-Z][A-Za-z']+)*)\s+Fork/i);
      if (m) return titleCase(`${m[1]} Fork`);

      return titleCase(s.split(" ").slice(0,3).join(" "));
    }
    const INCLUDE = /\b(River|Creek|Fork|Run|Brook|Branch|Headwaters)\b/i;
    const EXCLUDE = /\b(Canal|Slough|Ditch|Drain|Diversion|Aqueduct|Wastewater|Effluent|Outfall|Estuary|Tidal|Delta|Lagoon|Pond|Lake|Reservoir|Island)\b/i;
    function looksTrouty(name){
      if (!INCLUDE.test(name)) return false;
      if (EXCLUDE.test(name) && !/\b(Dam|Tailwater|Outlet)\b/i.test(name)) return false;
      if (EXTRA_EXCLUDE.test(name)) return false;
      if (/\b(at|near)\s+mouth\b/i.test(name)) return false;
      // exclude generic creeks unless whitelisted
      const label = normalizeRiverName(name);
      if (/\bCreek\b/i.test(label) && !TROUT_CREEK_WHITELIST.has(label)) return false;
      return true;
    }

    function distMi(a, b){
      const toRad = x => x * Math.PI / 180;
      const R = 3958.761;
      const dLat = toRad(b.lat - a.lat);
      const dLon = toRad(b.lon - a.lon);
      const lat1 = toRad(a.lat);
      const lat2 = toRad(b.lat);
      const h = Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)**2;
      return 2 * R * Math.asin(Math.sqrt(h));
    }
    function fishabilityScore(cfs){
      if (!isFinite(cfs) || cfs <= 0) return 0;
      // Very high flows are generally unsafe for trout wading except big steelhead rivers
      if (cfs > 15000) return 0.05;
      // Piecewise preferences (small/med trout streams)
      if (cfs < 40) return 0.15;
      if (cfs < 120) return 0.8;
      if (cfs < 350) return 1.0;
      if (cfs < 900) return 0.7;
      if (cfs < 1500) return 0.45;
      return 0.3;
    }

    // Fishability from 30d ratio (if available)
    function fishabilityFromRatio(ratio){
      if (!isFinite(ratio) || ratio <= 0) return 0;
      if (ratio < 0.25) return 0.2;
      if (ratio < 0.6)  return 0.6;
      if (ratio <= 1.5) return 1.0;
      if (ratio <= 2.5) return 0.7;
      return 0.4;
    }

    function tempGate(tempC){
      if (!isFinite(tempC)) return { drop:false, penalty:0, bonus:0, scoreHint:0.6 };
      const F = tempC*9/5+32;
      if (F > 72) return { drop:true, penalty:1, bonus:0, scoreHint:0 };
      if (F > 68) return { drop:false, penalty:0.05, bonus:0, scoreHint:0.4 };
      if (F >= 52 && F <= 62) return { drop:false, penalty:0, bonus:0.05, scoreHint:1.0 };
      if (F <= 38) return { drop:false, penalty:0, bonus:0, scoreHint:0.2 };
      return { drop:false, penalty:0, bonus:0, scoreHint:0.7 };
    }

    function freshnessScore(ts){
      const hrs = ageHours(ts);
      if (!isFinite(hrs)) return 0.3;
      if (hrs <= 6) return 1.0;
      if (hrs <= 24) return 0.9;
      if (hrs <= 72) return 0.7;
      if (hrs <= 168) return 0.5;
      return 0.3;
    }
    function seasonScore(tailwater){
      if (!SUMMER) return 0.5;
      if (tailwater === true) return 1.0;
      return 0.6; // slight boost otherwise
    }
    function distanceScore(mi){
      const cap = 300;
      return Math.max(0, 1 - Math.min(mi, cap)/cap);
    }
    function round2(x){ return Math.round(x*100)/100; }

    function ageHours(ts){
      const t = Date.parse(ts);
      if (!isFinite(t)) return Infinity;
      return (Date.now() - t) / 3.6e6;
    }
    function isFreshEnough(ts){
      const hrs = ageHours(ts);
      return isFinite(hrs) && hrs <= 24*7;
    }
    function freshnessChip(ts){
      const hrs = ageHours(ts);
      let meta = FRESH[FRESH.length-1];
      for (const f of FRESH){ if (hrs <= f.maxHrs){ meta = f; break; } }
      const label = !isFinite(hrs) ? "n/a" : meta.label;
      const color = !isFinite(hrs) ? "#ccc" : meta.color;
      const rel = !isFinite(hrs) ? "" : hrs < 1 ? `${Math.max(1, Math.round(hrs*60))} m ago` : hrs < 24 ? `${Math.round(hrs)} h ago` : `${Math.floor(hrs/24)} d ago`;
      return `<span class="chip" style="background:${color}" title="${ts || 'n/a'}">${label}</span> <span class="small">${rel}</span>`;
    }
    function tempBadge(tempC){
      if (!isFinite(tempC)) return `<span class="chip" style="background:#ccc">n/a</span>`;
      const F = tempC*9/5+32;
      let bg = "#77c5ff";
      if (F <= 65) bg = "#a7e07a";
      else if (F <= 68) bg = "#ffdd57";
      else bg = "#ff6b6b";
      return `<span class="chip" style="background:${bg}">${Math.round(F)}¬∞F</span>`;
    }

    function regsUrl(label){ return g(`${label} fishing regulations site:wildlife.ca.gov`); }

    function buildExplain({tempC, cfs, factors}){
      const parts = [];
      if (isFinite(tempC)){
        const F = Math.round(tempC*9/5+32);
        if (F > 68) parts.push(`Temp ${F}¬∞F ‚Äì warm`);
        else if (F >= 52 && F <= 62) parts.push(`Temp ${F}¬∞F ‚Äì ideal`);
        else parts.push(`Temp ${F}¬∞F`);
      } else {
        parts.push('Temp n/a');
      }
      if (isFinite(cfs)){
        if (cfs > 5000) parts.push(`Flow ${cfs} cfs ‚Äì high`);
        else parts.push(`Flow ${cfs} cfs`);
      } else {
        parts.push('Flow n/a');
      }
      const f = factors || {};
      if (f.temp && f.temp !== 1) parts.push(`temp√ó${f.temp}`);
      if (f.flow && f.flow !== 1) parts.push(`flow√ó${f.flow}`);
      if (f.season && f.season !== 1) parts.push(`season√ó${f.season}`);
      if (f.fresh && f.fresh !== 1) parts.push(`fresh√ó${f.fresh}`);
      if (f.elev && f.elev !== 1) parts.push(`elev√ó${f.elev}`);
      return parts.join(' ‚Ä¢ ');
    }

    function inferTailwater(label, siteName){
      const n = `${label} ${siteName||""}`.toLowerCase();
      if (/(tailwater|below dam|dam|outlet|powerhouse|reservoir)/.test(n)) return true;
      return LARGE_TAILWATER_WHITELIST.has(label);
    }
    function isSpringFed(label){
      if (SPRINGFED_WHITELIST.has(label)) return true;
      return /spring/.test(label.toLowerCase()) || label === 'Fall River' || label === 'Hat Creek';
    }
    function isSteelheadRiver(label){ return STEELHEAD_RIVERS.has(label); }

    async function getOrigin(){
      const HOME = { lat: 37.0897, lon: -122.089 };
      return new Promise(resolve => {
        if (!navigator.geolocation){
          resolve(HOME);
          return;
        }
        const opt = { enableHighAccuracy: false, timeout: 8000, maximumAge: 60000 };
        navigator.geolocation.getCurrentPosition(
          pos => resolve({ lat: pos.coords.latitude, lon: pos.coords.longitude }),
          ()  => resolve(HOME),
          opt
        );
      });
    }

    function milesToBBox(center, radiusMi){
      const latDeg = radiusMi / 69.0;
      const lonDeg = radiusMi / (69.172 * Math.cos(center.lat * Math.PI/180));
      return { west: center.lon - lonDeg, east: center.lon + lonDeg, south: center.lat - latDeg, north: center.lat + latDeg };
    }

    // Split a large bbox into a grid of smaller tiles to avoid USGS 400 errors
    function tileBBoxes(bbox, maxSpanDeg = 0.5){
      const latSpan = Math.max(0, bbox.north - bbox.south);
      const lonSpan = Math.max(0, bbox.east - bbox.west);
      const nLat = Math.max(1, Math.ceil(latSpan / maxSpanDeg));
      const nLon = Math.max(1, Math.ceil(lonSpan / maxSpanDeg));
      const tiles = [];
      for (let i = 0; i < nLat; i++){
        const s = bbox.south + (latSpan * i / nLat);
        const n = bbox.south + (latSpan * (i+1) / nLat);
        for (let j = 0; j < nLon; j++){
          const w = bbox.west + (lonSpan * j / nLon);
          const e = bbox.west + (lonSpan * (j+1) / nLon);
          tiles.push({ west: w, south: s, east: e, north: n });
        }
      }
      return tiles;
    }

    function clampTile(t){
      const west = Math.max(-180, Math.min(180, t.west));
      const east = Math.max(-180, Math.min(180, t.east));
      const south = Math.max(-90, Math.min(90, t.south));
      const north = Math.max(-90, Math.min(90, t.north));
      if (east <= west || north <= south) return null;
      return { west, east, south, north };
    }

    function splitTile(t){
      const c = clampTile(t);
      if (!c) return [];
      const midLat = (c.north + c.south) / 2;
      const midLon = (c.east + c.west) / 2;
      return [
        { west: c.west, south: c.south, east: midLon, north: midLat },
        { west: midLon, south: c.south, east: c.east, north: midLat },
        { west: c.west, south: midLat, east: midLon, north: c.north },
        { west: midLon, south: midLat, east: c.east, north: c.north }
      ];
    }

    // California bounding box (approx)
    function isInCalifornia(lat, lon){
      return lat >= 32 && lat <= 42 && lon >= -125 && lon <= -114.1;
    }

    // Fetch active sites with flow inside bbox
    async function fetchSitesInBBox(bbox, onProgress){
      const tiles = tileBBoxes(bbox, 0.5);
      const map = new Map();
      const concurrency = 1;
      let idx = 0;
      let completed = 0;
      async function fetchTileRecursive(t, depth){
        const c = clampTile(t);
        if (!c) return;
        const url = `https://waterservices.usgs.gov/nwis/iv/?format=json&bBox=${c.west},${c.south},${c.east},${c.north}&parameterCd=${PARAM_FLOW}&siteType=ST&siteStatus=active`;
        try {
          const res = await fetch(url);
          if (res.ok){
            const json = await res.json();
            const series = json?.value?.timeSeries || [];
            for (const ts of series){
              const info = ts?.sourceInfo;
              const code = info?.siteCode?.[0]?.value;
              const name = info?.siteName || "";
              const lat = Number(info?.geoLocation?.geogLocation?.latitude);
              const lon = Number(info?.geoLocation?.geogLocation?.longitude);
              if (code && isFinite(lat) && isFinite(lon) && isInCalifornia(lat, lon) && !map.has(code)){
                map.set(code, { siteCode: code, siteName: name, lat, lon });
              }
            }
            return;
          }
          if (res.status === 400 && depth < 2){
            const parts = splitTile(c);
            for (const p of parts){
              await fetchTileRecursive(p, depth+1);
            }
          }
        } catch (e) {
          // ignore network errors
        }
      }
      async function worker(){
        while (true){
          const i = idx++;
          if (i >= tiles.length) break;
          const t = tiles[i];
          try {
            await fetchTileRecursive(t, 0);
          } finally {
            completed++;
            if (onProgress) onProgress(completed, tiles.length);
          }
        }
      }
      const workers = Array.from({length: concurrency}, () => worker());
      await Promise.all(workers);
      return Array.from(map.values());
    }

    // Fallback: fetch all CA stream gauges with discharge via IV by state
    async function fetchSitesInStateCA(){
      const url = `https://waterservices.usgs.gov/nwis/iv/?format=json&stateCd=CA&parameterCd=${PARAM_FLOW}&siteType=ST&siteStatus=active`;
      const res = await fetch(url);
      if (!res.ok) throw new Error(`USGS state fetch ${res.status}`);
      const json = await res.json();
      const series = json?.value?.timeSeries || [];
      const map = new Map();
      for (const ts of series){
        const info = ts?.sourceInfo;
        const code = info?.siteCode?.[0]?.value;
        const name = info?.siteName || "";
        const lat = Number(info?.geoLocation?.geogLocation?.latitude);
        const lon = Number(info?.geoLocation?.geogLocation?.longitude);
        if (code && isFinite(lat) && isFinite(lon) && isInCalifornia(lat, lon) && !map.has(code)){
          map.set(code, { siteCode: code, siteName: name, lat, lon });
        }
      }
      return Array.from(map.values());
    }

    // Progressively expand radius from the user's location, fetching small rings
    async function fetchSitesAround(origin, maxRadiusMi, stepMi, onProgress){
      const step = Math.max(25, stepMi || 75);
      const all = new Map();
      let doneTiles = 0, totalTiles = 0;
      // Pre-compute total tiles for status
      for (let r = step; r <= maxRadiusMi; r += step){
        const tiles = tileBBoxes(milesToBBox(origin, r), 2);
        totalTiles += tiles.length;
      }
      const progress = (inc) => {
        doneTiles += inc;
        if (onProgress) onProgress(doneTiles, totalTiles);
      };
      for (let r = step; r <= maxRadiusMi; r += step){
        const bbox = milesToBBox(origin, r);
        const before = doneTiles;
        const ringSites = await fetchSitesInBBox(bbox, (d, t) => {
          // convert per-bbox progress to global approx
          const inc = d - (doneTiles - before);
          if (inc > 0) progress(inc);
        });
        for (const s of ringSites){
          if (!all.has(s.siteCode)) all.set(s.siteCode, s);
        }
      }
      return Array.from(all.values());
    }

    // Batch fetch flow + temp
    async function fetchFlowAndTemp(ids){
      if (!ids.length) return {};
      const out = {};
      const chunk = 80;
      for (let i = 0; i < ids.length; i += chunk){
        const slice = ids.slice(i, i+chunk);
        const url = `https://waterservices.usgs.gov/nwis/iv/?format=json&parameterCd=${PARAM_FLOW},${PARAM_TEMP}&sites=${slice.join(",")}`;
        const res = await fetch(url);
        if (!res.ok) continue;
        const json = await res.json();
        const series = json?.value?.timeSeries || [];
        for (const ts of series){
          const site = ts?.sourceInfo?.siteCode?.[0]?.value;
          const varCd = ts?.variable?.variableCode?.[0]?.value;
          const vals = ts?.values?.[0]?.value;
          if (!site || !vals || !vals.length) continue;
          const latest = vals[vals.length-1];
          if (!out[site]) out[site] = {};
          if (varCd === PARAM_FLOW){
            out[site].cfs = Number(latest.value);
            out[site].flowTime = latest.dateTime;
          } else if (varCd === PARAM_TEMP){
            out[site].tempC = Number(latest.value);
            out[site].tempTime = latest.dateTime;
          }
        }
      }
      return out;
    }

    // Fetch 30-day IV history per site to compute median CFS (small batch, limited concurrency)
    async function fetchMedian30d(ids){
      const out = {};
      let idx = 0;
      const maxConcurrency = 4;
      async function worker(){
        while (idx < ids.length){
          const i = idx++;
          const id = ids[i];
          const url = `https://waterservices.usgs.gov/nwis/iv/?format=json&parameterCd=${PARAM_FLOW}&sites=${id}&period=P30D`;
          try{
            const res = await fetch(url);
            if (!res.ok) continue;
            const json = await res.json();
            const series = json?.value?.timeSeries?.[0];
            const vals = series?.values?.[0]?.value || [];
            const nums = vals.map(v => Number(v.value)).filter(x => isFinite(x) && x > 0);
            if (nums.length){
              const sorted = nums.sort((a,b)=>a-b);
              const mid = Math.floor(sorted.length/2);
              const med = sorted.length % 2 ? sorted[mid] : (sorted[mid-1] + sorted[mid]) / 2;
              out[id] = med;
            }
          }catch{}
        }
      }
      const workers = Array.from({length: Math.min(maxConcurrency, ids.length)}, () => worker());
      await Promise.all(workers);
      return out;
    }

    // Elevation lookup (meters) using Open-Elevation; caches in localStorage
    async function fetchElevations(sites){
      const out = {};
      const need = [];
      for (const s of sites){
        const key = `elv:${s.lat.toFixed(3)},${s.lon.toFixed(3)}`;
        const cached = localStorage.getItem(key);
        if (cached){ out[s.siteCode] = Number(cached); continue; }
        need.push({s,key});
      }
      if (!need.length) return out;
      // batch up to 100 locations
      for (let i=0;i<need.length;i+=100){
        const slice = need.slice(i,i+100);
        const qs = slice.map(x => `${x.s.lat},${x.s.lon}`).join("|");
        const url = `https://api.open-elevation.com/api/v1/lookup?locations=${qs}`;
        try{
          const res = await fetch(url);
          if (!res.ok) continue;
          const json = await res.json();
          const results = json?.results || [];
          results.forEach((r, idx) => {
            const {s,key} = slice[idx] || {};
            if (!s) return;
            const m = Number(r.elevation);
            if (isFinite(m)){
              out[s.siteCode] = m; localStorage.setItem(key, String(m));
            }
          });
        }catch{}
      }
      return out;
    }

    // Multipliers
    function tempFactor(tempC, label, isWhitelisted){
      // warmwater list heavy penalty
      if (WARM_WATER_LIST.has(label)) return 0.1;
      if (!isFinite(tempC)){
        if (SUMMER && !isWhitelisted) return 0.5;
        return isWhitelisted ? 1.0 : 0.8;
      }
      const F = tempC*9/5+32;
      if (F > 65) return 0.6;
      if (F > 60) return 0.9;
      if (F >= 50 && F <= 60) return 1.0;
      if (F < 40 && !WARM_WATER_LIST.has(label)) return 0.8;
      return 1.0;
    }
    function flowFactor(cfs, label, tailwater){
      if (!isFinite(cfs) || cfs <= 0) return (TROUT_RIVER_WHITELIST.has(label)||TROUT_CREEK_WHITELIST.has(label)) ? 1.0 : 0.5;
      // hide below 10cfs unless spring-fed handled elsewhere; here penalty
      if (cfs < 10) return 0.5;
      if (cfs > 5000 && !(tailwater && LARGE_TAILWATER_WHITELIST.has(label))) return 0.25;
      return 1.0;
    }
    function seasonFactor(label, tailwater, springFed){
      if (MONTH>=6 && MONTH<=9){
        if (tailwater || springFed) return 1.0;
        return 0.6;
      }
      if (MONTH===11 || MONTH<=2){
        if (isSteelheadRiver(label)) return 1.1;
      }
      return 0.5;
    }
    function freshnessFactor(ts){
      const hrs = ageHours(ts);
      if (!isFinite(hrs)) return 0.5;
      if (hrs <= 1) return 1.0;
      if (hrs <= 24) return 0.9;
      if (hrs <= 72) return 0.7;
      if (hrs <= 168) return 0.5;
      return 0.2; // caller may still drop >7d
    }
    function elevationFactor(label, elevMeters){
      const elevFt = isFinite(elevMeters) ? elevMeters*3.28084 : null;
      if (elevFt !== null && elevFt < 1500 && !TROUT_RIVER_WHITELIST.has(label) && !TROUT_CREEK_WHITELIST.has(label)){
        return 0.6; // heavily penalize lowland non-whitelist
      }
      return 1.0;
    }

    async function build(){
      const radius = Number(document.getElementById('radius').value || 250);
      const limit = Number(document.getElementById('limit').value || 25);
      const origin = await getOrigin();
      document.getElementById('origin').textContent = `Origin ${origin.lat.toFixed(2)}, ${origin.lon.toFixed(2)}`;
      const bbox = milesToBBox(origin, radius);
      const statusEl = document.getElementById('status');
      statusEl.textContent = `Loading USGS‚Ä¶`;
      let sites = [];
      try {
        // First try CA-wide to avoid tile storms; then intersect with radius
        statusEl.textContent = 'Loading USGS CA-wide‚Ä¶';
        sites = await fetchSitesInStateCA();
        // Then, if still empty (unlikely), fall back to rings
        if (!sites.length){
          statusEl.textContent = `No sites via state. Trying rings‚Ä¶`;
          sites = await fetchSitesAround(origin, radius, 75, (done, total) => { statusEl.textContent = `Loading USGS‚Ä¶ (${done}/${total})`; });
        }
      } catch (err) {
        statusEl.textContent = `Failed to load USGS data: ${err?.message || err}`;
        return;
      }
      // normalize first, then trouty-filter on normalized label
      sites = sites.map(s => ({...s, label: normalizeRiverName(s.siteName), dist: distMi(origin, s)}));
      sites = sites.filter(s => looksTrouty(s.label))
                   .sort((a,b) => a.dist - b.dist);

      // Fork-aware grouping: treat forks as separate labels, group to parent for display (stored later)
      const forksMap = {
        "North Fork Yuba River": "Yuba River",
        "Middle Fork Yuba River": "Yuba River",
        "South Fork Yuba River": "Yuba River"
      };
      const chosen = [];
      const seen = new Set();
      const maxCandidates = Math.max(limit * 3, 150);
      for (const s of sites){
        const label = s.label;
        if (seen.has(label)) continue;
        seen.add(label);
        chosen.push({ ...s, parent: forksMap[label] || label });
        if (chosen.length >= maxCandidates) break;
      }

      const ids = chosen.map(s => s.siteCode);
      const [data, elevations, med30] = await Promise.all([
        fetchFlowAndTemp(ids),
        fetchElevations(chosen),
        fetchMedian30d(ids)
      ]);

      const hasTempOnly = document.getElementById('hasTempOnly').checked;
      const hideWarm = document.getElementById('hideWarm').checked;
      const rows = chosen.map(s => {
        const d = data[s.siteCode] || {};
        const cfs = isFinite(d.cfs) ? Math.round(d.cfs) : null;
        const tail = inferTailwater(s.label, s.siteName);
        const spring = isSpringFed(s.label);
        const tempMeta = tempGate(d.tempC);
        let f = fishabilityScore(d.cfs);
        const median = med30[s.siteCode];
        if (isFinite(d.cfs) && isFinite(median) && median > 0){
          const ratio = d.cfs / median;
          f = fishabilityFromRatio(ratio);
          // Clamp high flow non-large-tailwater
          if (d.cfs > 5000 && !(tail && LARGE_TAILWATER_WHITELIST.has(s.label))){
            f = Math.min(f, 0.25);
          }
        }
        const ds = Math.max(0, 1 - Math.min(s.dist, 300)/300);
        const fs = freshnessScore(d.flowTime);
        const seasonF = seasonFactor(s.label, tail, spring);
        // multiplicative factors per spec
        const factors = {
          temp: tempFactor(d.tempC, s.label, TROUT_RIVER_WHITELIST.has(s.label)||TROUT_CREEK_WHITELIST.has(s.label)),
          flow: flowFactor(cfs, s.label, tail),
          season: seasonF,
          fresh: freshnessFactor(d.flowTime),
          elev: elevationFactor(s.label, elevations[s.siteCode])
        };
        // base (add whitelist bonus)
        let base = 0.5*f + 0.3*ds + 0.2*seasonScore(tail);
        if (TROUT_RIVER_WHITELIST.has(s.label) || TROUT_CREEK_WHITELIST.has(s.label)) base *= 1.2;
        if (isFinite(d.tempC) && d.tempC*9/5+32 > 68) base = Math.min(base, 0.4);
        const final = base * factors.temp * factors.flow * factors.season * factors.fresh * factors.elev;
        // Hatch multiplier (simple presence-based bonus)
        let hatchBonus = 1.0;
        const hatch = HATCH_DATA[s.label];
        if (hatch && hatch[MONTH]) hatchBonus = 1.05;
        const scored = Math.max(0, Math.min(1, final)) * hatchBonus;
        return {
          name: s.label,
          siteName: s.siteName,
          lat: s.lat, lon: s.lon,
          miles: Math.round(s.dist),
          cfs, flowTime: d.flowTime || null, tempC: d.tempC,
          score: round2(scored),
          species: guessSpecies(s.lat, s.lon),
          flies: bestFliesForSeason(),
          tailwater: tail,
          springFed: spring,
          parent: s.parent,
          explain: buildExplain({tempC: d.tempC, cfs, factors})
        };
      }).sort((a,b) => b.score - a.score);

      // Apply post-filters
      let filtered = rows.filter(r => {
        // freshness
        if (!isFreshEnough(r.flowTime)) return false;
        // temp toggles and hard summer drop
        const F = isFinite(r.tempC) ? (r.tempC*9/5+32) : null;
        if (SUMMER && F !== null && F > 70) return false;
        if (hideWarm && F !== null && F > 68) return false;
        // has temp only toggle
        if (hasTempOnly && !isFinite(r.tempC)) return false;
        // low flow exclusions per refinement
        if (r.cfs !== null && r.cfs <= 0) return false;
        if (r.cfs !== null && r.cfs < 1) return false;
        if (r.cfs !== null && r.cfs < 5 && !r.tailwater) return false;
        // low elevation summer penalty handled in scoring; here allow
        return true;
      });
      // enforce user limit after filtering
      filtered = filtered.slice(0, limit);

      const tbody = document.querySelector("#table tbody");
      tbody.innerHTML = filtered.map((r, i) => {
        const fresh = freshnessChip(r.flowTime);
        const temp = tempBadge(r.tempC);
        const species = speciesChips(r.species);
        const regsHref = g(`${r.name} fishing regulations site:wildlife.ca.gov`);
        const mapHref = mapHrefFor(r.lat, r.lon);
        return `
          <tr>
            <td>${i+1}</td>
            <td>
              ${r.name}
              <div class="small">${r.siteName}</div>
              <div class="meta">${species}${r.parent && r.parent !== r.name ? ` ‚Ä¢ <span class="small">(${r.parent})</span>` : ''}</div>
              <div class="small">Flies: ${r.flies.join(", ")}</div>
              <div class="small">
                ${r.tailwater ? '<span class="flag tailwater">Tailwater</span>' : ''}
                ${!r.tailwater && r.springFed ? '<span class="flag springfed">Spring‚Äëfed</span>' : ''}
              </div>
            </td>
            <td>${r.cfs ?? "n/a"}<div class="small">${fresh}</div><div class="small" style="margin-top:4px;">${temp}</div></td>
            <td>${r.miles}</td>
            <td title="${r.explain}">${r.score}</td>
            <td>
              <a class="btn" href="${mapHref}" target="_blank" rel="noopener">Map</a>
              <a class="btn" href="${regsHref}" target="_blank" rel="noopener">Regs</a>
              <details class="dropdown">
                <summary class="btn">Ask GPT ‚ñæ</summary>
                <div class="menu">
                  <a href="${chatGPTUrl(buildRegsPrompt(r.name, r.siteName))}" target="_blank" rel="noopener">Regulations</a>
                  <a href="${chatGPTUrl(buildSuggestedFliesPrompt(r.name))}" target="_blank" rel="noopener">Suggested Flies</a>
                  <a href="${chatGPTUrl(buildLocalShopsPrompt(r.lat, r.lon))}" target="_blank" rel="noopener">Local Fly Shops</a>
                </div>
              </details>
            </td>
          </tr>
        `;
      }).join("");
      statusEl.textContent = `${filtered.length} rivers within ${radius} mi`;

      // Persist current results for download
      window.__riverRankerResults = filtered;
    }

    document.getElementById('refresh').addEventListener('click', build);
    document.getElementById('download-json').addEventListener('click', () => {
      try {
        const data = JSON.stringify({
          generatedAt: new Date().toISOString(),
          origin: document.getElementById('origin').textContent,
          season: document.getElementById('season-pill').textContent,
          radiusMi: Number(document.getElementById('radius').value || 0),
          limit: Number(document.getElementById('limit').value || 0),
          hasTempOnly: document.getElementById('hasTempOnly').checked,
          hideWarm: document.getElementById('hideWarm').checked,
          rows: (window.__riverRankerResults || [])
        }, null, 2);
        const blob = new Blob([data], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `river-ranker-${Date.now()}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      } catch (e) {
        alert('Could not generate JSON export.');
      }
    });

    // How it works modal logic
    const howLink = document.getElementById('how-link');
    const howModal = document.getElementById('how-modal');
    const howClose = document.getElementById('how-close');
    function openHow(){ howModal.style.display = 'flex'; }
    function closeHow(){ howModal.style.display = 'none'; }
    howLink.addEventListener('click', (e)=>{ e.preventDefault(); openHow(); });
    howClose.addEventListener('click', closeHow);
    howModal.addEventListener('click', (e)=>{ if (e.target === howModal) closeHow(); });

    // PWA install
    if ("serviceWorker" in navigator){
      window.addEventListener("load", () => navigator.serviceWorker.register("./sw.js"));
    }

    // First load
    build();
  </script>
</body>
</html>
